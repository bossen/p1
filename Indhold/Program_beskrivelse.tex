Vi har udviklet et program, der kan foretage komprimering, og dekomprimering af tekst, ved hjælp af Huffman komprimering. Programmet er skrevet i programmeringssproget C, hvilket vil gøre det meget effektivt, hvis ellers koden er skrevet ordentligt.
Teksten der bliver indlæst i programmet bliver komprimeret ud fra et statisk Huffman træ, genereret ud fra vores analyse af SMS-beskeder.


\subsubsection{Konvertering til GSM 7 bit (GSM 03.38)}
Tegnsættet brugt i GSM hedder GSM 03.38 - dog bedre kendt som GSM 7-bit - og beskriver hvordan forskellige tegn udtrykkes med 7 bit indenfor GSM standarden. For eksempel udtrykkes '@' i ASCII som 0100 0000, mens det i GSM 7-bit udtrykke som 000 0000. Prototypen til komprimering og dekomprimering er skrevet i C. For at simulere at C programmet kører på en mobiltelefon, var det nødvændigt at konvertere de indlæste tegn til de decimal-værdier der bliver brugt i GSM standarden. Dette sker ved at decimal værdien for et tegn, bliver skiftet ud med decimal værdien for det tilsvarende tegn i GSM tegnsættet. Da ASCII tegnsættet ikke indeholder alle tegn der fremkommer i GSM 7-bit var det nødvændigt at implementere et andet tegnsæt, der indeholdt de manglende tegn. Til dette formål blev UTF-8 tegnsættet valgt. Brugerinput foregår derfor fra et UTF-8 tekst-dookument, som bliver indlæst i programmet, hvorefter UTF-8 værdierne bliver udskiftet med deres tilsvarende værdier i GSM 7-bit. Da vi ikke direkte kan arbejde i et 7 bit system på computeren, bliver de 7 bit, gemt i en 8 bit byte, der har et 0 foran for det grundlæggende tegnsæt, og 1 foran de udvidede tegn.

\subsubsection{Komprimering}

De data der skal komprimeres, bliver læst fra en tekstfil på harddisken ind i programmet. Tekstfilen skal være i tegnsættet UTF8, og når teksten er læst ind, bliver de forskellige tegn konverteret til GSM 7 bit. Disse data, bliver så sendt til komprimerings funktionen. Komprimerings funktionen, sørger så for at generere et Huffman træ, ud fra en fil på harddisken, med frekvenser for forskellige tegn. Dette kan så enten være "gsmfreq.txt", lavet ud fra analysen af SMS-beskederne, eller "wikifreq.txt", lavet ud fra analysen af Wikipedia artikler.
Når træet er lavet, bliver teksten så komprimeret, ved at den binære værdi for hvert tegn bliver skiftet ud med den tilsvarende binære Huffman sekvens. Denne sekvens, bliver sendt videre til en buffer, og hver gang denne buffer indeholder 8 bit (1 byte), skriver den til harddisken. Filen den den skriver til er en binær fil, og denne fil, vil efterfølgende kunne bruges til at genskabe de originale data (dekomprimering).

\subsubsection{Dekomprimering}

Dekomprimeringen af teksten ved hjælp af vores program, foregår ved nogle simple trin her beskrevet. Huffman træet bliver igen genereret ud fra en fil med frekvenser. Denne fil skal være den samme, som da der blev komprimeret, da det genererede Huffman træ, skal være nøjagtigt magen til. Træet kunne i stedet have været gemt i en fil for sig selv, eller beskrevet i starten af den binære fil.
Herefter påbegynder læsningen af den binære fil, der indeholder de komprimerede data. Der bliver læst bit for bit, fra venstre mod højre, og programmet går enten til højre eller venstre i Huffman træet, indtil programmet ender på et tegn. Dette tegn bliver skrevet til en tekstfil på harddisken, fx "output.txt". Algoritmen starter igen fra toppen af træet, og de næste bit i den binære fil bliver læst, og skrevet til disken, indtil alle data er dekomprimeret.

\subsubsection{Indeksering}
For at gøre komprimeringen hurtigere bliver træet indekseret. Dette gøres ved at køre én gang igennem alle kombinationer i træet, hvorefter placeringen af alle blade bliver tilknyttet dets GSM 7-bit værdi. Dette gør at når et tegn i inputstrømmen mødes, kan der lynhurtigt findes frem til dets blad, blot ved tegnets værdi. Dette er især nyttigt ved komprimering hvor der sidenhen kan komprimeres ved at køre opad i træet indtil roden mødes, mens der hver gang bliver gemt hvorvidt den aktuelle plads var forbundet til venstre eller højre side af den foregående. Når roden mødes har vi derfor den aktuelle Huffman kode baglæns, da der køres opad. denne kode spejles siden for at få den reelle kode, hvorefter den bliver skrevet til output strømmen.